<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Octopress Blog]]></title>
  <link href="http://engili.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://engili.github.io/"/>
  <updated>2018-07-29T11:45:08+08:00</updated>
  <id>http://engili.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS Tips]]></title>
    <link href="http://engili.github.io/blog/2017/05/14/oc-ios-tips/"/>
    <updated>2017-05-14T06:58:39+08:00</updated>
    <id>http://engili.github.io/blog/2017/05/14/oc-ios-tips</id>
    <content type="html"><![CDATA[<!-- more -->


<h3>1.在block执行期间，weak引用强持有</h3>

<pre><code class="obj-c">__weak typedef(someClass) weakClass = someClass;
[xxx setHandler:^{
    typedef(someClass) strongClass = weakClass;
    [strongClass doSomething];
}];
</code></pre>

<ul>
<li>为了避免强引用环，在使用闭包时，一些引入的对象，都使用不增加引用计数的<code>weak</code>指针持有，但当使用的时候，为了避免对象被提前释放，可以用<code>strong</code>指针持有，可以确保在使用该对象的时候，不会被释放。</li>
<li>使用不带修饰的指针变量，默认是带有<code>__strong</code>修饰</li>
</ul>


<h3>2. UISwitch 重复触发action方法</h3>

<p>理论上，只用当用户点击了<code>UISwitch</code>,才会触发，<code>vauleChange</code> 的action方法 但是实际开发中，发现iOS10机型上，如果在action方法里调用了-<code>setOn:animated:</code>或者<code>setOn:</code> ，就会多触发一次action方法。</p>

<h4>解决方案</h4>

<ol>
<li>避免在valueChange方法里调用-setOn:animated:或setOn:</li>
<li>如果无法避免，使用dispatch_async,在主队列执行这些方法（这个方法有个缺点，比较卡的手机会看到闪动的现象）</li>
</ol>


<pre><code class="obj-c">- (IBAction)valueChanged:(id)sender {
    ...
    dispatch_async(dispatch_get_main_queue(), ^{
       [sender setOn:YES];
    });
    ...
}
</code></pre>

<p>3.iOS 10 以下机型不会出现这个问题，iOS11 待验证</p>

<h4>参考：</h4>

<p><a href="https://stackoverflow.com/questions/39566361/uiswitch-seton-animated-does-not-work-as-document">UISwitch setOn(:, animated:) does not work as document</a></p>

<h3>3. Xcode8 生成CoreData NSManagedObject 报Duplicate symbol error</h3>

<p>上周写CoreData的时候，当使用Editor的Create NSManagedObject SubClass 生成好对应Entity的ManagedObject后，编译的时候报Duplicate symbol error，意思是符号重复定义的错误，一脸蒙蔽好吧，都是系统生成的，我什么都没有做=。=</p>

<p>然后网上搜了一下，搜到了问题的原因和解决方案 <a href="http://stackoverflow.com/questions/40460307/duplicate-symbol-error-when-adding-nsmanagedobject-subclass-duplicate-link">duplicate-symbol-error-when-adding-nsmanagedobject-subclass-duplicate-link xcode-beta-8-cant-create-core-data</a></p>

<h4>原因</h4>

<p>Xcode 8 的.xcdatamodeId 文件会自动生成那些Entity的类，当你在Editor->Create NSManagedObject SubClass 再次生成这些Entity类的时候，编译的时候，就会有符号重定义的错误</p>

<h4>解决方案</h4>

<ul>
<li>当你不需要自己修改NSManagedObject 文件时候，就使用Xcode生成的文件，直接引用头文件就好。</li>
<li>当你需要自己修改NSManagedObject 文件，在Xcode中选中.xcdatamodeId 文件 在右侧属性栏中， <del>把Tools Version 修改成小于8.0的版本 ，然后就可以使用Editor 生成NSManagedObject类了。</del> 修改Entity Inspector 里Class对应的Codegen 如下图：
<img src="https://github.com/engili/engili.github.io/raw/master/images/ios-tips-01.png" alt="" /></li>
</ul>


<h3>4. Swift 单例</h3>

<h4>使用类常量</h4>

<pre><code class="swift">class MTNetWorkManager {

static let shared = MTNetWorkManager(baseURL: API.baseURL)

let baseURL: URL

private init(baseURL: URL) {
self.baseURL = baseURL
}
}
//外部调用 MTNetWorkManager.shared
</code></pre>

<h4>使用类方法</h4>

<pre><code class="swift">class MTNetWorkManager {

static private let sharedInstance = {

let shared = MTNetWorkManager(baseURL: API.baseURL)

//Configure 可以做一些初始化配置

return shared

}()

let baseURL: URL

private init(baseURL: URL) {
self.baseURL = baseURL
}


static func shared() {
return sharedInstance
}
}

//外部调用 MTNetWorkManager.shared()
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LayoutMargin & preservesSuperviewLayoutMargins 学习笔记]]></title>
    <link href="http://engili.github.io/blog/2017/05/14/layoutMagrin-preservesSuperviewLayoutMargins-notes/"/>
    <updated>2017-05-14T06:58:39+08:00</updated>
    <id>http://engili.github.io/blog/2017/05/14/layoutMagrin-preservesSuperviewLayoutMargins-notes</id>
    <content type="html"><![CDATA[<!-- more -->


<h3>发现问题</h3>

<p>在IB中拖放tableView，大小为设置为屏幕大小后，添加了四个方向的约束，发现，约束的值居然不是和想象中不太一样，不是0。</p>

<p><img src="https://github.com/engili/engili.github.io/raw/master/images/layout_note_1.png" alt="" /></p>

<p>接着打开attribute inspector,发现约束信息如下：
<img src="https://raw.githubusercontent.com/engili/engili.github.io/master/images/layout_note_2.png" alt="" /></p>

<p>在这里发现Second Item是superView 的 leading Margin. 而不是superView的leading，所以约束的值不是0，但leading margin又是什么？</p>

<h3>Layout Magrin</h3>

<p>通过查找文档，发现这是iOS 8 以后，UIView 新增的一个属性，layoutMargins. 表示一个View的内边距。</p>

<h3>文档</h3>

<p><code>@property(nonatomic) UIEdgeInsets layoutMargins;</code> The default spacing to use when laying out content in the view</p>

<pre><code class="obj-c">typedef struct UIEdgeInsets {
    CGFloat top, left, bottom, right;  // specify amount to inset (positive) for each of the edges. values can be negative to 'outset'
} UIEdgeInsets;
</code></pre>

<p>这个属性类似Android中的padding，用于父View设置子View布局的内边距。</p>

<p>The default margins are eight points on each side.</p>

<p>默认值是8个点，可修改。</p>

<p>If the view is a view controller’s root view, the system sets and manages the margins. The top and bottom margins are set to zero points. The side margins vary depending on the current size class, but can be either 16 or 20 points. You cannot change these margins.</p>

<p>但如果，是ViewController的rootView，layoutMargins 是系统设置和控制的，不能修改。（文章最开始的tableView到 leading Margin 约束为 -16.就说明，left margin是16点。）</p>

<p>到这里，其实对layoutMargins理解都较为清晰，但是文档中还提到了一个与layoutMargins 相关的属性： preservesSuperviewLayoutMargins</p>

<p>When the edge of your view is close to the edge of the superview and the preservesSuperviewLayoutMargins property is YES, the actual layout margins may be increased to prevent content from overlapping the superview’s margins.</p>

<p>读完感觉字面意思都懂，但就是不知道是什么意思。</p>

<h3>preservesSuperviewLayoutMargins</h3>

<p><code>@property(nonatomic) BOOL preservesSuperviewLayoutMargins;</code> A Boolean value indicating whether the current view also respects the margins of its superview. The default value of this property is NO.</p>

<p>一个BOOL值，决定当前View布局是否也考虑父View的layoutMargins. 默认是NO.</p>

<p>到这里还是晕的，没看懂这个属性是干嘛，继续看文档。</p>

<h3>文档</h3>

<p>When the value of this property is YES, the superview’s margins are also considered when laying out content. This margin affects layouts where the distance between the edge of a view and its superview is smaller than the corresponding margin.</p>

<p>当这个属性是YES的时候，父view的layoutMargins会被考虑到当前View的布局中。也就是说，当前View和父View的内边距，小于父View相应layoutMargins中对应的内边距时，父View的内边距会决定当前View的布局。还是有些抽象。</p>

<p>For example, you might have a content view whose frame precisely matches the bounds of its superview. When any of the superview’s margins is inside the area represented by the content view and its own margins, UIKit adjusts the content view’s layout to respect the superview’s margins. The amount of the adjustment is the smallest amount needed to ensure that content is also inside the superview’s margins.</p>

<p>这里大概的意思就是，你有一个contentView，它的大小和父View一样大的你设置了contentView的preservesSuperviewLayoutMargins为YES，当你对contentView中的子View进行布局的时候，如果有子View的所在位置（比如：子View到contentView的左边距，小于父View的LayoutMargin 对应的左内边距）UIKit就会对子View进行一些调整。 感觉看了这一段稍微清晰了一些，可是写代码想实现一个demo的时候，发现这个preservesSuperviewLayoutMargins属性好像并没有什么卵用。 最后再Google上搜到了这篇文章。 <a href="https://www.shinobicontrols.com/blog/ios8-day-by-day-day-32-layout-margins">iOS8 Day-by-Day :: Day 32 :: Layout Margins</a></p>

<p>然后自己实现了一个 demo 如下：</p>

<pre><code class="obj-c">- (void)viewDidLoad {
    [super viewDidLoad];

    //创建一个红色的View，大小和手机屏幕一样大，
    //layoutMargin 为（100，100，100，100）
    UIView *redView = [[UIView alloc] init];
    redView.backgroundColor = [UIColor redColor];
    redView.translatesAutoresizingMaskIntoConstraints = NO;
    redView.layoutMargins = UIEdgeInsetsMake(100, 100, 100, 100);
    [self.view addSubview:redView];
    [self.view addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"H:|-(0)-[redView]-(0)-|" options:NSLayoutFormatDirectionLeadingToTrailing metrics:nil views:NSDictionaryOfVariableBindings(redView)]];
    [self.view addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"V:|-(0)-[redView]-(0)-|" options:NSLayoutFormatDirectionLeadingToTrailing metrics:nil views:NSDictionaryOfVariableBindings(redView)]];

    //创建一个绿色的View，作为我们的ContentView，父View为红色的View
    //约束为到红色View各边距为10，但红色View 的layoutMargin 还是再绿色View内
    //设置绿色View preservesSuperviewLayoutMargins 为YES
    UIView *greenView = [[UIView alloc] init];
    greenView.backgroundColor = [UIColor greenColor];
    greenView.translatesAutoresizingMaskIntoConstraints = NO;
    greenView.preservesSuperviewLayoutMargins = YES;
    [redView addSubview:greenView];
    [redView addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"H:|-(10)-[greenView]-(10)-|" options:NSLayoutFormatDirectionLeadingToTrailing metrics:nil views:NSDictionaryOfVariableBindings(greenView)]];
    [redView addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"V:|-(10)-[greenView]-(10)-|" options:NSLayoutFormatDirectionLeadingToTrailing metrics:nil views:NSDictionaryOfVariableBindings(greenView)]];

    //创建一个蓝色View，作为绿色View的子View
    UIView *blueView = [[UIView alloc] init];
    blueView.backgroundColor = [UIColor blueColor];
    blueView.translatesAutoresizingMaskIntoConstraints = NO;
    [greenView addSubview:blueView];

    //注意，leading 约束对应的第二item 属性为 leading.margin
    [greenView addConstraint: [NSLayoutConstraint constraintWithItem:blueView attribute:NSLayoutAttributeLeading relatedBy:NSLayoutRelationEqual toItem:greenView attribute:NSLayoutAttributeLeadingMargin multiplier:1.0 constant:0.0]];
    // trailing 属性 为父View trailig - 8.0// 8.0 是默认layout Margin
    [greenView addConstraint: [NSLayoutConstraint constraintWithItem:blueView attribute:NSLayoutAttributeTrailing relatedBy:NSLayoutRelationEqual toItem:greenView attribute:NSLayoutAttributeTrailing multiplier:1.0 constant:-8.0]];
    [greenView addConstraint: [NSLayoutConstraint constraintWithItem:blueView attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:greenView attribute:NSLayoutAttributeTop multiplier:1.0 constant:0.0]];
    [greenView addConstraint: [NSLayoutConstraint constraintWithItem:blueView attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:greenView attribute:NSLayoutAttributeBottom multiplier:1.0 constant:0.0]];
}
</code></pre>

<p><img src="https://github.com/engili/engili.github.io/raw/master/images/layout_note_3.png" alt="" /></p>

<h3>总结</h3>

<p>最后总结一下preservesSuperviewLayoutMargins生效的要点：（如果总结的不对希望大家指正~） 1.preservesSuperviewLayoutMargins 只在自动布局情况下生效 2.contentView（设置preservesSuperviewLayoutMargins的View）的父View的LayoutMargin中，至少存在contentView 某一个方向到父View的边距，小于父View LayoutMargin 对应的内边距。（就比如上面栗子中，绿色View到红色View的左边距是10，红色View的LayoutMargin中对应的左内边距为100） 3.设置自动布局约束的时候，一定要设置Margin相关的约束(iOS8以上有效)</p>

<pre><code class="obj-c">typedef NS_ENUM(NSInteger, NSLayoutAttribute) {
   ...

    NSLayoutAttributeLeftMargin NS_ENUM_AVAILABLE_IOS(8_0),
    NSLayoutAttributeRightMargin NS_ENUM_AVAILABLE_IOS(8_0),
    NSLayoutAttributeTopMargin NS_ENUM_AVAILABLE_IOS(8_0),
    NSLayoutAttributeBottomMargin NS_ENUM_AVAILABLE_IOS(8_0),
    NSLayoutAttributeLeadingMargin NS_ENUM_AVAILABLE_IOS(8_0),
    NSLayoutAttributeTrailingMargin NS_ENUM_AVAILABLE_IOS(8_0),
    NSLayoutAttributeCenterXWithinMargins NS_ENUM_AVAILABLE_IOS(8_0),
    NSLayoutAttributeCenterYWithinMargins NS_ENUM_AVAILABLE_IOS(8_0),

};
</code></pre>

<h3>思考</h3>

<p>现在基本上弄清楚了，LayoutMargin和preservesSuperviewLayoutMargins属性，以及如何使用，但是对他们在自动布局的实际使用场景还是没有思考太清楚，没有明白苹果为什么会设置这两个属性，特别是preservesSuperviewLayoutMargins属性。 = =</p>
]]></content>
  </entry>
  
</feed>
